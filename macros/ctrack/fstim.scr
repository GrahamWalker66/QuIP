# flickering stimulus, computed on the gpu
max_warnings 3

Set zoom 2
Set period 120
Set start_freq 50	# 0.5 x 100
Set sample_freq	60	# samples per second
Assign radius 200/$zoom

Assign sigma 10/$zoom

< $macro_dir/compute/gaussian.mac


Assign stim_w 64*12/$zoom
Assign stim_h 600/$zoom


Viewer stim_v $zoom*$stim_w $zoom*$stim_h

gl window stim_v quit

Set max_atten 200
Set a_factor 1

Define Attenuate_Twinkle 0
Assign a_factor $slider_val/($max_atten)
.

Define SetSigma 0
Assign sigma $slider_val/$zoom
Gaussian_At g_gaussian $sigma 0 0
.

Define SetFreq 0
Assign f100 $slider_val
Assign freq $f100/100
Assign period 1/$freq	# period in seconds
Mul_Var period $sample_freq	# seconds * samples/sec = samples
# period may have a fraction, but we want it to evenly divide
# traj_len, so that things match up when we reset
Assign n_periods round($traj_len/$period)
Assign period $traj_len/$n_periods
Recompute_Coords
.

Set min_sigma 1
Set max_sigma 200

Set min_freq 1	# 0.01 Hz
Set max_freq 1000 # 10 Hz

interface
  panel control_panel 400 300
  decorate control_panel
    adjuster Attenuation Attenuate_Twinkle 0 $max_atten $max_atten
    adjuster Sigma SetSigma $min_sigma $max_sigma $zoom*$sigma
    adjuster Freq_x_100 SetFreq $min_freq $max_freq $start_freq
    button QUIT exit
    quit
  control
    show control_panel
    quit
  quit
Posn_Window control_panel 0 700

    
Image h_fbuf $stim_h $stim_w 1 float
Image h_cbuf $stim_h $stim_w 1 complex

cuda quit

Image g_gaussian $stim_h $stim_w 1 float
Image s_gaussian $stim_h $stim_w 1 float
Image g_noise $stim_h $stim_w 1 float
Image g_b $stim_h $stim_w 1 u_byte
Image g_pattern $stim_h $stim_w 1 bit
Image g_bitmap $stim_h $stim_w 1 bit

data areas select ${DEFAULT_CUDA_DEVICE}_host quit quit

Set n_minutes 2
Set seconds_per_minute 60
Set frames_per_second 60

Set traj_len $n_minutes*$seconds_per_minute*$frames_per_second
Vector coords $traj_len 2 float

Define Recompute_Coords 0
Ramp1D coords{0} 0 8*atan(1)/$period
VSin coords{1} coords{0}
VCos coords{0} coords{0}
VSMul coords coords $radius
.

Recompute_Coords

cuda
  cuda_gl
    buffer g_rgb $stim_w $stim_h 3
    quit
  quit
cuda
  cuda_gl
    viewer stim_v
    quit
  quit

VUni g_noise
VSMul g_noise g_noise 255
Convert g_rgb{0} g_noise
Convert g_rgb{1} g_noise
Convert g_rgb{2} g_noise
#advise "Showing noise image"
#cuda cuda_gl load stim_v g_rgb quit quit
#gl vbl_wait 1 swap_buffers quit
#Pause

Define Show_Bits 1 bitmap
advise "Show_Bits $1"
compute compare ss_select $1 g_b 0 255 quit quit

VMov g_rgb{0} g_b VMov g_rgb{1} g_b VMov g_rgb{2} g_b
cuda cuda_gl load stim_v g_rgb quit quit
gl vbl_wait 1 swap_buffers quit
Pause
.

# Now binarize the noise
compute compare vsm_gt g_pattern g_noise 255/2 quit quit
#Show_Bits g_pattern

Define Show_It 2 image string
cuda dnload h_fbuf $1 quit
Disp_Image h_fbuf stim_v
advise $2
Pause
.

Gaussian_At g_gaussian $sigma 0 0
#Show_It g_gaussian 'gaussian'

VSMul s_gaussian g_gaussian 255
Convert g_rgb{0} s_gaussian
Convert g_rgb{1} s_gaussian
Convert g_rgb{2} s_gaussian

#VUni g_noise
#compute compare vsm_gt g_pattern g_noise 0.5 quit quit

Equivalence a_pattern g_pattern 1 1 nrows(g_pattern) ncols(g_pattern)/64 1 uint64
Equivalence a_bitmap g_bitmap 1 1 nrows(g_bitmap) ncols(g_bitmap)/64 1 uint64

#advise 'Doing 300 frames'
#date
#repeat 300
Set t 0
do
  Assign x value(coords[$t]{0})
  Assign y value(coords[$t]{1})
  Gaussian_At g_gaussian $sigma $x $y
  VUni g_noise
  VSMul s_gaussian g_gaussian $a_factor
  compute compare vvm_gt g_bitmap s_gaussian g_noise quit quit

  VVXor a_pattern a_pattern a_bitmap
  compute compare ss_select g_pattern g_b 0 255 quit quit
  VMov g_rgb{0} g_b VMov g_rgb{1} g_b VMov g_rgb{2} g_b
  cuda cuda_gl load stim_v g_rgb quit quit
  # load no longer does swap_buffers...
  gl vbl_wait 1 swap_buffers quit
  os events quit
  Increment t
  If $t>=$traj_len "Set t 0"
  while 1
 # end
date

Pause
exit


